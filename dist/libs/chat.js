"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGraffitiFeedIndex = exports.readSingleMessage = exports.uploadObjectToBee = exports.feedReaderFromRoomId = exports.feedWriterFromRoomId = exports.updateUserList = exports.writeOneMessageToAggregatedFeed = exports.fetchAllMessages = exports.writeToOwnFeed = exports.registerUser = exports.initChatRoom = void 0;
const bee_js_1 = require("@ethersphere/bee-js");
const graffitiUtils_1 = require("../utils/graffitiUtils");
const chat_1 = require("../utils/chat");
const ethers_1 = require("ethers");
const common_1 = require("../utils/common");
const bmt_js_1 = require("@fairdatasociety/bmt-js");
const hex_1 = require("../utils/beeJs/hex");
const other_1 = require("../utils/other");
// Initialize the bee instance
const bee = new bee_js_1.Bee('http://localhost:1633');
//const bee = new Bee("http://161.97.125.121:1933");
const ETH_ADDRESS_LENGTH = 42; // Be careful not to use EthAddress from bee-js,
const ConsensusID = 'SwarmStream'; // Used for Graffiti feed
// This function will create 2 feeds: a Users feed, and an AggregatedChat
// This will be called on the side of the Streamer (aggregator)
function initChatRoom(topic, privKey, stamp) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const wallet = new ethers_1.ethers.Wallet(privKey); // This is the same privKey, as used for the Stream
            // Create the Users feed, that is used to register to the chat
            const usersFeedResult = yield createUsersFeed(topic, stamp);
            if (!usersFeedResult)
                throw "Could not create Users feed!";
            // Create the AggregatedChat feed, that is the real chat feed
            let chatWriter = yield createAggregatedFeedWriter(topic, wallet);
            if (!chatWriter)
                throw "Could not create FeedWriter for the aggregated chat!";
            return {
                usersRef: usersFeedResult,
                chatWriter: chatWriter
            };
        }
        catch (error) {
            console.error('There was an error while initalizing the chat for the feed (initChatRoom).');
            (0, other_1.logErrorToFile)(`There was an error while initalizing the chat for the feed (initChatRoom): ${error}`);
            return null;
        }
    });
}
exports.initChatRoom = initChatRoom;
// Create Users feed, where users will register (by inserting a User object to the feed)
// The Aggregator (Streamer) will poll those feeds, that belong to these users
function createUsersFeed(topic, stamp) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.info("Initiating Users feed...");
            const usersFeedID = (0, chat_1.generateUsersFeedId)(topic); // Graffiti feed for users to register
            const privateKey = (0, graffitiUtils_1.getConsensualPrivateKey)(usersFeedID); // Can be generated by any participant (who knows the stream topic)
            const wallet = (0, graffitiUtils_1.getGraffitiWallet)(privateKey);
            const graffitiSigner = {
                address: bee_js_1.Utils.hexToBytes(wallet.address.slice(2)),
                sign: (data) => __awaiter(this, void 0, void 0, function* () {
                    return yield wallet.signMessage(data);
                })
            };
            const consensusHash = bee_js_1.Utils.keccak256Hash(ConsensusID);
            let exist = yield bee.isFeedRetrievable('sequence', graffitiSigner.address, consensusHash);
            if (exist)
                throw "This feed already exists!";
            console.info("Creating feed manifest...");
            const manifestResult = yield bee.createFeedManifest(stamp, 'sequence', consensusHash, graffitiSigner.address);
            console.info("Feed manifest created with ref ", manifestResult.reference);
            return manifestResult.reference;
        }
        catch (error) {
            console.error("There was an error while creating Users feed.");
            (0, other_1.logErrorToFile)(`There was an error while creating Users feed: ${error}`);
            return null;
        }
    });
}
// This is the feed that will contain the whole chat, all the messages are aggregated to this feed (by the Streamer)
function createAggregatedFeedWriter(streamTopic, wallet) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.info("Initiating aggregated feed...");
            const humanReadableTopic = (0, chat_1.generateRoomId)(streamTopic);
            const topic = bee.makeFeedTopic(humanReadableTopic);
            const feedWriter = bee.makeFeedWriter('sequence', topic, wallet.privateKey);
            console.info("Aggregated feed created, address of owner: ", feedWriter.owner);
            return feedWriter;
        }
        catch (error) {
            console.error("There was an error while trying to create the AggregatedChat feed.");
            (0, other_1.logErrorToFile)(`There was an error while trying to create the AggregatedChat feed: ${error}`);
            return null;
        }
    });
}
// Will write a User object to the Users feed
// This will be called on client side (user adds self to feed)
function registerUser(topic, streamerAddress, username, stamp) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.info("Registering user...");
            const roomId = (0, chat_1.generateUsersFeedId)(topic);
            const wallet = ethers_1.ethers.Wallet.createRandom();
            const address = wallet.address;
            const timestamp = Date.now();
            const signature = yield wallet.signMessage(JSON.stringify({ username, address, timestamp }));
            localStorage.setItem((0, chat_1.generateUniqId)(topic, streamerAddress), address);
            localStorage.setItem((0, chat_1.generateUserOwnedFeedId)(topic, address), wallet.privateKey); // We save the private key for this chat (only this chat)
            const user = {
                username: username,
                address: address,
                timestamp: timestamp,
                signature: signature
            };
            const userRef = yield uploadObjectToBee(user, stamp);
            if (!userRef)
                throw "Could not upload User object to Swarm (reference is null)";
            console.info("User object uploaded, reference: ", userRef.reference);
            const feedWriter = feedWriterFromRoomId(roomId);
            let feedReference = null;
            let uploadSuccess = false;
            const MAX_TRY_ATTEMPT = 10;
            do { // Try to upload User object, if not successful, try again
                try {
                    let index = "";
                    try {
                        const res = yield feedWriter.download();
                        console.log("REFERENCE: ", res.reference);
                        index = res.feedIndexNext;
                        console.log("res", res);
                    }
                    catch (error) {
                        index = 0;
                        console.log("DOWNLOADING INDEX FAILED");
                    }
                    console.debug("Uploading to feed...");
                    feedReference = yield feedWriter.upload(stamp, userRef.reference, { index });
                    for (let i = 0; i < MAX_TRY_ATTEMPT; i++) {
                        try {
                            console.debug("Read back...");
                            const readBackRef = yield feedWriter.download({ index });
                            readBackRef.reference;
                            console.debug("Download actual data...");
                            const readBack = yield bee.downloadData(readBackRef.reference);
                            const json = readBack.json();
                            console.warn("validateUserObject(json): ", (0, chat_1.validateUserObject)(json));
                            console.warn("json.username == user.username: ", json.username == user.username);
                            uploadSuccess = (0, chat_1.validateUserObject)(json) && json.username == user.username;
                            console.warn("&&: ", uploadSuccess);
                            if (uploadSuccess)
                                break;
                        }
                        catch (error) {
                            console.error(`Readback failed. Attempt count: ${i}`);
                            yield (0, common_1.sleep)(10 * 1000);
                        }
                    }
                }
                catch (error) {
                    console.error(`Error registering User ${user.username}, retrying...`);
                    (0, other_1.logErrorToFile)(`Error registering User ${user.username}, retrying... ${error}`);
                }
            } while (!uploadSuccess);
            return feedReference;
        }
        catch (error) {
            console.error("There was an error while trying to register user (chatroom)");
            (0, other_1.logErrorToFile)(`There was an error while trying to register user (chatroom): ${error}`);
            return null;
        }
    });
}
exports.registerUser = registerUser;
// Write a new message to the feed of the user. Every user has a feed.
// Index is stored in React state (we are not fetching the feed index from Swarm)
// This is called client side
function writeToOwnFeed(topic, streamerAddress, index, messageObj, stamp) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const address = localStorage.getItem((0, chat_1.generateUniqId)(topic, streamerAddress));
            if (!address)
                throw "Could not get address from local storage!"; // This suggests that the user haven't registered yet for this chat
            const feedID = (0, chat_1.generateUserOwnedFeedId)(topic, address);
            const privateKey = localStorage.getItem(feedID); // Private key for this single chat is stored in local storage
            const feedTopicHex = bee.makeFeedTopic(feedID);
            if (!privateKey)
                throw "Could not get private key from local storage!";
            /*const uploadRes = await*/ uploadObjectToBee(messageObj, stamp); // We first upload the message object to Swarm
            /*if (!uploadRes) throw "Could not upload message object to Swarm!";*/
            const uint8 = (0, graffitiUtils_1.serializeGraffitiRecord)(messageObj);
            const newChunk = (0, bmt_js_1.makeChunkedFile)(uint8);
            const newRef = (0, hex_1.bytesToHex)(newChunk.address());
            const feedWriter = bee.makeFeedWriter('sequence', feedTopicHex, privateKey);
            const ref = yield feedWriter.upload(stamp, newRef, { index }); // We write to specific index, index is stored in React state
            console.info("Wrote message to own feed with ref ", ref);
            return ref;
        }
        catch (error) {
            console.error(`There was an error while trying to write own feed (chat), index: ${index}, message: ${messageObj.message}`);
            (0, other_1.logErrorToFile)(`There was an error while trying to write own feed (chat), index: ${index}, message: ${messageObj.message}: ${error}`);
            return null;
        }
    });
}
exports.writeToOwnFeed = writeToOwnFeed;
// Reads all new messages from Swarm, each user has a feed, input userList will include the last read index
// Will return the new messages, for each user
// This is called on the side of the Streamer (aggregator)
function fetchAllMessages(userList, streamTopic) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // List of promises, that will give back { user, messages }, if successful
            const promiseList = userList.map((user) => __awaiter(this, void 0, void 0, function* () {
                const messages = [];
                const feedID = (0, chat_1.generateUserOwnedFeedId)(streamTopic, user.address);
                const topic = bee.makeFeedTopic(feedID);
                const feedReader = bee.makeFeedReader('sequence', topic, user.address);
                const max = user.index + 10;
                let i = 0;
                for (i = user.index; i < max; i++) { // Looping through new messages for single user, but only read max
                    try {
                        const feedUpdate = yield feedReader.download({ index: i });
                        const data = yield bee.downloadData(feedUpdate.reference);
                        const json = data.json();
                        messages.push(json);
                        console.info(`Messages for user ${user.address} (i: ${i}): `, messages);
                    }
                    catch (error) {
                        break; // We quit the loop, if no new messages
                    }
                }
                const userWithIndex = Object.assign(Object.assign({}, user), { index: i });
                return {
                    user: userWithIndex,
                    messages: messages
                };
            }));
            return Promise.all(promiseList);
        }
        catch (error) {
            console.error("There was an error reading user feeds (fetchAllMessages)");
            (0, other_1.logErrorToFile)(`There was an error reading user feeds (fetchAllMessages): ${error}`);
            return null;
        }
    });
}
exports.fetchAllMessages = fetchAllMessages;
// Write the messages of all users to an aggregated feed, in chronological order.
// This is called on the side of the Streamer (aggregator)
function writeOneMessageToAggregatedFeed(message, chatWriter, chatIndex, stamp) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            //const uploadRes = await uploadObjectToBee(message, stamp);                    // This data should already exist on Swarm, we just don't know the reference
            //if (!uploadRes) throw "Error uploading message to Swarm!";                    // but it's probably good that we give it more time-to-live
            const uint8 = (0, graffitiUtils_1.serializeGraffitiRecord)(message); // don't upload the chunk, just calculate ref
            const newChunk = (0, bmt_js_1.makeChunkedFile)(uint8);
            const newRef = (0, hex_1.bytesToHex)(newChunk.address());
            chatWriter.upload(stamp, newRef, { index: chatIndex });
            console.info(`Wrote message to index ${chatIndex}, address: ${chatWriter.owner}, topic: ${chatWriter.topic}`);
            return chatIndex + 1;
        }
        catch (error) {
            console.error("There was an error while trying to write aggregated feed for the chat.");
            (0, other_1.logErrorToFile)(`There was an error while trying to write aggregated feed for the chat: ${error}`);
            return null;
        }
    });
}
exports.writeOneMessageToAggregatedFeed = writeOneMessageToAggregatedFeed;
// This is createUserList as well. If no input user list and index, it will create the user list
// This is called on the side of the Streamer (aggregator)
function updateUserList(topic_1) {
    return __awaiter(this, arguments, void 0, function* (topic, index = 0, users = []) {
        try {
            const roomId = (0, chat_1.generateUsersFeedId)(topic);
            const lastIndex = yield getGraffitiFeedIndex(roomId);
            console.info("Updating user list. Last index: ", lastIndex);
            const feedReader = feedReaderFromRoomId(roomId);
            if (index < 0 || index > lastIndex)
                throw `Invalid index: ${index}`;
            for (let i = index; i <= lastIndex; i++) {
                try {
                    const feedEntry = yield feedReader.download({ index: i });
                    const data = yield bee.downloadData(feedEntry.reference);
                    const json = data.json();
                    const isValid = (0, chat_1.validateUserObject)(json);
                    if (!isValid) {
                        throw ("Validation failed");
                    }
                    else {
                        const userExists = users.some((user) => user.address === json.address);
                        if (userExists) {
                            throw "Duplicate User entry";
                        }
                        else {
                            users.push(Object.assign(Object.assign({}, json), { index: 0 })); // We add the User object to the list, if it's not duplicate
                        }
                    }
                }
                catch (error) {
                    console.error("Skipping element.");
                    (0, other_1.logErrorToFile)(`Skipping element: ${error}`);
                    continue;
                }
            }
            console.log("Users: ", users);
            return { users, lastReadIndex: lastIndex };
        }
        catch (error) {
            console.error("There was an error while trying to insert new users to users state.");
            (0, other_1.logErrorToFile)(`There was an error while trying to insert new users to users state: ${error}`);
            return null;
        }
    });
}
exports.updateUserList = updateUserList;
// Graffiti feed writer from RoomID (can't be used for normal, non-Graffiti reader)
function feedWriterFromRoomId(roomId) {
    const privateKey = (0, graffitiUtils_1.getConsensualPrivateKey)(roomId);
    const wallet = (0, graffitiUtils_1.getGraffitiWallet)(privateKey);
    const graffitiSigner = {
        address: bee_js_1.Utils.hexToBytes(wallet.address.slice(2)), // convert hex string to Uint8Array
        sign: (data) => __awaiter(this, void 0, void 0, function* () {
            return yield wallet.signMessage(data);
        }),
    };
    const consensusHash = bee_js_1.Utils.keccak256Hash(ConsensusID);
    return bee.makeFeedWriter('sequence', consensusHash, graffitiSigner);
}
exports.feedWriterFromRoomId = feedWriterFromRoomId;
// Graffiti feed reader from RoomID (can't be used for normal, non-Graffiti reader)
function feedReaderFromRoomId(roomId) {
    const privateKey = (0, graffitiUtils_1.getConsensualPrivateKey)(roomId);
    const wallet = (0, graffitiUtils_1.getGraffitiWallet)(privateKey);
    const graffitiSigner = {
        address: bee_js_1.Utils.hexToBytes(wallet.address.slice(2)), // convert hex string to Uint8Array
        sign: (data) => __awaiter(this, void 0, void 0, function* () {
            return yield wallet.signMessage(data);
        }),
    };
    const consensusHash = bee_js_1.Utils.keccak256Hash(ConsensusID);
    return bee.makeFeedReader('sequence', consensusHash, graffitiSigner.address);
}
exports.feedReaderFromRoomId = feedReaderFromRoomId;
// Uploads any JavaScript object to Swarm, gives back reference if successful, null otherwise
function uploadObjectToBee(jsObject, stamp) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield bee.uploadData(stamp, (0, graffitiUtils_1.serializeGraffitiRecord)(jsObject), { redundancyLevel: 4 });
            return result;
        }
        catch (error) {
            return null;
        }
    });
}
exports.uploadObjectToBee = uploadObjectToBee;
// Reads a message from AggregatedChat, this should be the same as Graffiti feed version, but input roomId is different
function readSingleMessage(index, streamTopic, streamerAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const aggregatedChatID = (0, chat_1.generateRoomId)(streamTopic); // Human readable topic name, for the aggregated chat
            const topic = bee.makeFeedTopic(aggregatedChatID);
            const feedReader = bee.makeFeedReader('sequence', topic, streamerAddress);
            console.info(`address: ${feedReader.owner} topic: ${feedReader.topic}`);
            const recordPointer = yield feedReader.download({ index }); // Fetch reference to data
            console.info("RecordPointer: ", recordPointer);
            const data = yield bee.downloadData(recordPointer.reference); // Fetch data
            return JSON.parse(new TextDecoder().decode(data)); // Return message object
        }
        catch (e) {
            // Don't spam the console
            if (e.status != 500) {
                console.error('There was an error, while reading single Message');
                (0, other_1.logErrorToFile)(`There was an error, while reading single Message: ${e}`);
            }
            return false;
        }
    });
}
exports.readSingleMessage = readSingleMessage;
// Current index for Graffiti feed, used by createUserList
function getGraffitiFeedIndex(roomId) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const feedReader = yield feedReaderFromRoomId(roomId);
            const feedUpdate = yield feedReader.download();
            return parseInt(feedUpdate.feedIndex, 16);
        }
        catch (error) {
            console.error('There was an error while trying to get feed index');
            (0, other_1.logErrorToFile)(`There was an error while trying to get feed index: ${error}`);
            return -1;
        }
    });
}
exports.getGraffitiFeedIndex = getGraffitiFeedIndex;
